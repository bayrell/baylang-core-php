"use strict;";if(typeof Runtime=="undefined")Runtime={};if(typeof Runtime.Unit=="undefined")Runtime.Unit={};Runtime.Unit.AssertHelper=class{static equalValueType(value1,value2,message){let type1=Runtime.rtl.getType(value1);let type2=Runtime.rtl.getType(value2);Runtime.rtl.assert(type1==type2,message)}static equalValue(value1,value2,message){this.equalValueType(value1,value2,message);let value_type1=Runtime.rtl.getType(value1);let value_type2=Runtime.rtl.getType(value2);Runtime.rtl.assert(value_type1==value_type2,message);if(Runtime.rtl.isScalarValue(value1)){Runtime.rtl.assert(value1===value2,message);return}if(value_type1=="collection"){this.equalCollection(value1,value2,message);return}if(value_type1=="dict"){this.equalDict(value1,value2,message);return}Runtime.rtl.assert(false,message)}static equalCollection(c1,c2,message){if(c1.count()!=c2.count()){Runtime.rtl.assert(false,message)}for(let i=0;i<c1.count();i++){let value1=c1.get(i);let value2=c2.get(i);this.equalValue(value1,value2,message)}}static equalDict(d1,d2,message){let d1_keys=d1.keys();let d2_keys=d2.keys();for(let i=0;i<d1_keys.count();i++){let key1=d1_keys.get(i);if(!d2.has(key1)){Runtime.rtl.assert(false,message)}let value1=d1.get(key1);let value2=d2.get(key1);this.equalValue(value1,value2,message)}for(let i=0;i<d2_keys.count();i++){let key2=d2_keys.get(i);if(!d1.has(key2)){Runtime.rtl.assert(false,message)}}}_init(){}static getClassName(){return"Runtime.Unit.AssertHelper"}static getMethodsList(){return null}static getMethodInfoByName(field_name){return null}static getInterfaces(){return[]}};window["Runtime.Unit.AssertHelper"]=Runtime.Unit.AssertHelper;"use strict;";if(typeof Runtime=="undefined")Runtime={};if(typeof Runtime.Unit=="undefined")Runtime.Unit={};Runtime.Unit.Test=class extends Runtime.Entity.Entity{_init(){super._init()}static getClassName(){return"Runtime.Unit.Test"}static getMethodsList(){return null}static getMethodInfoByName(field_name){return null}static getInterfaces(){return[]}};window["Runtime.Unit.Test"]=Runtime.Unit.Test;"use strict;";if(typeof Runtime=="undefined")Runtime={};if(typeof Runtime.Unit=="undefined")Runtime.Unit={};Runtime.Unit.TestProvider=class extends Runtime.BaseProvider{async start(){this.tests_list=Runtime.rtl.getContext().getEntities("Runtime.Unit.UnitTest")}getTests(){return this.tests_list}get(pos){return this.tests_list.get(pos)}count(){return this.tests_list.count()}static async run(test_name){if(test_name==undefined)test_name="";let provider=new Runtime.Unit.TestProvider;await provider.start();if(test_name==""){Runtime.rtl.print("List of all tests:");for(let i=0;i<provider.count();i++){let test=provider.get(i);Runtime.rtl.print(i+1+String(") ")+String(test.name))}return}await provider.runTestByName(test_name)}static async runAll(){let provider=new Runtime.Unit.TestProvider;await provider.start();for(let i=0;i<provider.count();i++){let test=provider.get(i);Runtime.rtl.print("Run "+String(test.name));let error_code=await provider.runTestByName(test.name);if(error_code!=1){return}}}async runTestByName(test_name){let error_code=0;let arr=Runtime.rs.split("::",test_name);if(arr.count()==1){error_code=await this.runTestClass(arr.get(0))}else{error_code=await this.runTestMethod(arr.get(0),arr.get(1))}return error_code}static isTestMethod(method_info){let annotations=method_info["annotations"];if(annotations){for(let j=0;j<annotations.count();j++){let annotation=annotations.get(j);if(annotation instanceof Runtime.Unit.Test){return true}}}return false}getTestMethods(class_name){let getMethodsList=new Runtime.Callback(class_name,"getMethodsList");let getMethodInfoByName=new Runtime.Callback(class_name,"getMethodInfoByName");let methods=getMethodsList.apply();methods=methods.filter(method_name=>{let method_info=getMethodInfoByName.apply(new Runtime.Vector(method_name));return this.constructor.isTestMethod(method_info)});return methods}async runTestClass(class_name){let error_code=1;let methods=this.getTestMethods(class_name);for(let i=0;i<methods.count();i++){let method_name=methods.get(i);let result=await this.runTestMethod(class_name,method_name);if(result!=1){error_code=-1;break}}if(error_code==1){Runtime.rtl.print(Runtime.rtl.color("green","Success"))}return error_code}async runTestMethod(class_name,method_name){let error_code=0;try{let callback=new Runtime.Callback(class_name,method_name);if(!callback.exists()){let obj=Runtime.rtl.newInstance(class_name);callback=new Runtime.Callback(obj,method_name)}if(callback.exists()){await Runtime.rtl.apply(callback);error_code=1;Runtime.rtl.print(class_name+String("::")+String(method_name)+String(" ")+String(Runtime.rtl.color("green","Ok")))}else{throw new Runtime.Exceptions.ItemNotFound(class_name+String("::")+String(method_name),"Method")}}catch(_ex){if(_ex instanceof Runtime.Exceptions.AssertException){var e=_ex;Runtime.rtl.print(class_name+String("::")+String(method_name)+String(" ")+String(Runtime.rtl.color("red","Error: "+String(e.getErrorMessage()))));error_code=e.getErrorCode()}else{throw _ex}}return error_code}_init(){super._init();this.tests_list=new Runtime.Vector}static getClassName(){return"Runtime.Unit.TestProvider"}static getMethodsList(){return null}static getMethodInfoByName(field_name){return null}static getInterfaces(){return[]}};window["Runtime.Unit.TestProvider"]=Runtime.Unit.TestProvider;"use strict;";if(typeof Runtime=="undefined")Runtime={};if(typeof Runtime.Unit=="undefined")Runtime.Unit={};Runtime.Unit.UnitTest=class extends Runtime.Entity.Entity{constructor(api_name){super(Runtime.Map.create({name:api_name}))}_init(){super._init()}static getClassName(){return"Runtime.Unit.UnitTest"}static getMethodsList(){return null}static getMethodInfoByName(field_name){return null}static getInterfaces(){return[]}};window["Runtime.Unit.UnitTest"]=Runtime.Unit.UnitTest;